//
//  Copyright Michael Hotchin
//
//  MIT License
//
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this
// software andassociated documentation files(the "Software"), to deal in the Software
// without restriction, including without limitation the rights to use, copy, modify,
// merge, publish, distribute, sublicense, and/or sell copies of the Software, andto
// permit persons to whom the Software is furnished to do so, subject to the following
// conditions :
//
// The above copyright notice andthis permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
// THE USE OR OTHER DEALINGS IN THE SOFTWARE
//

//
//  Build environment:  Visual Studio Community 2019
//

// bmper.exe <bitmap filename>
//
// Reads a Windows bitmap (.BMP) file, and outputs C++ code encoding the bitmap as a Run
// Length Encoded RGB 565 bitmap, suitable for use on many arduino displays.
//

#include <Windows.h>
#include <stdio.h>
#include <stdint.h>
#include <memory>
#include "CBitmapHandler.h"
#include <wil/resource.h>

//  The "Windows Implementation Library" provides RAII wrappers for many Win32 types.
using unique_FileMapping = wil::unique_any<const void *, decltype(&::UnmapViewOfFile), ::UnmapViewOfFile>;

WORD RGB_888_to_565(byte R, byte G, byte B)
{
	return ((WORD)(R & 0xF8) << 8) | ((WORD)(G & 0xFC) << 3) | ((WORD)(B & 0xF8) >> 3);
}


void printHeader(const WCHAR *name, const WCHAR *filename)
{
	wprintf_s(LR"(
//
//  This file is AUTOMATICALLY GENERATED, and should not be edited unless you are certain
//  that it will not be re-generated anytime in the future.  As generated code, the
//  copyright owner(s) of the generating program do NOT claim any copyright on the code
//  generated.
//
//  Run Length Encoded (RLE) bitmaps.  Each run is encoded as either one or two bytes,
//  with NO PADDING.  Thus, the data for each line of the bitmap is VARIABLE LENGTH, and
//  there is no way of determining where any line other than the first starts without
//  walking though the data.  
//
//  Note that one byte encoding ONLY occurs if the total number of colors is 16 or less,
//  and in that case the 'flags' member of the 'RLEBitmapInfo' will have the first bit
//  (0x01) set.
//
//  In that case, if the high 4 bits of the first byte are ZERO, then this is a 2 byte
//  run.  The first byte is the index of the color in the color palette, and the second
//  byte is the length.
//
//  Else, the lower 4 bits are the color index, and the upper 4 bits are the run length.
//
//  If the 'flags' member first bit is zero, then ALL runs are 2 byte runs.  The first
//  byte is the palette index, and the second is the run length.
//
//  In order to save PROGMEM for other uses, the bitmap data is placed in a section that
//  occurs near the END of the used FLASH.  So, this data should only be accessed using
//  the 'far' versions of the progmem functions - the usual versions are limited to the
//  first 64K of FLASH.
//
//  Data is from file '%s'.
//
)", filename);

	wprintf_s(L"\nconst byte %s_RLEBM_data[] PROGMEM_LATE = \n{\n\t", name);
}



void dumpPalette(
	const WCHAR *name,
	CBitmapHandler *pHandler)
{
	size_t newPaletteCount = pHandler->GetNumPaletteEntries();

	wprintf_s(L"const uint16_t %s_RLEBM_palette[] PROGMEM_LATE = \n{\n\t// Palette has %zd entries", name, newPaletteCount);

	for (size_t i = 0; i < newPaletteCount; i++)
	{
		if (i % 16 == 0)
		{
			wprintf(L"\n\t");
		}

		wprintf_s(L"0x%04x, ", pHandler->GetPaletteEntry(i));
	}

	wprintf_s(L"\n};\n\n\n");
}







int wmain(int argc, wchar_t *argv[], wchar_t * /*envp*/[])
{

	if (argc != 2)
	{
		wprintf_s(L"%s <bitmap filename>\n", argv[0]);
		wprintf_s(L"Read the bitmap file (extension .BMP), and outputs the C++ code to store\n");
		wprintf_s(L"   the bitmap data and retrieve it for rendering.\n");
		return -1;
	}

	wil::unique_hfile hFile(CreateFile(argv[1], GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));

	if (!hFile)
	{
		wprintf_s(L"Unable to open file '%s'.\n", argv[1]);
		return -1;
	}

	//  Map the file into memory so we can just walk through it using pointers.
	wil::unique_handle hMap(CreateFileMapping(hFile.get(), NULL, PAGE_READONLY, 0, 0, NULL));

	if (!hMap)
	{
		wprintf_s(L"Unable to create file mapping\n");

		return -1;
	}

	unique_FileMapping pFileMapping(MapViewOfFile(hMap.get(), FILE_MAP_READ, 0, 0, 0));

	if (!pFileMapping)
	{
		wprintf_s(L"Unable to MapViewOfFile.\n");

		return -1;
	}


	//  Generate variable names from the file name.
	wchar_t  name[64] = { L'\0' };
	wchar_t *pPos = name;

	const wchar_t *pName = wcsrchr(argv[1], L'\\');

	//  Locate filename portion of argument
	if (pName == nullptr)
	{
		pName = argv[1];
	}
	else
	{
		pName++;
	}

	//  Create a name suitable for variables, derived from the filename.
	while ((*pName != L'.') && (*pName != L'\0'))
	{
		//  Replace problematic characters
		if (isalnum(*pName))
			*pPos++ = *pName;
		else
			*pPos++ = L'_';

		pName++;
	}

	*pPos = L'\0';

	//  Bitmap file is now readable in memory, starting at 'pFileMapping'
	const BITMAPFILEHEADER *pbmh = reinterpret_cast<const BITMAPFILEHEADER *>(pFileMapping.get());

	const BITMAPINFOHEADER *pbmHeader = (const BITMAPINFOHEADER *)((const byte *)pFileMapping.get()+sizeof(BITMAPFILEHEADER));

	//  We process VERY specific bitmap types.  Bitmap version 3,4,5, with 8, 24, 32 bit
	//  colors per pixel, no compression.
	DWORD dwHeaderSize = pbmHeader->biSize;

	if ((dwHeaderSize != 40) && (dwHeaderSize != 108) && (dwHeaderSize != 124))
	{
		wprintf_s(L"Unknown BM type %x.\n", dwHeaderSize);

		return -1;
	}

	if (pbmHeader->biCompression != BI_RGB)
	{
		if (pbmHeader->biCompression == BI_BITFIELDS)
		{
			//  Use a bitmap header structure that has the RGB masks.  Make sure they are
			//  the expected default values.  Default order (in bytes) BGRA. 
			const BITMAPV4HEADER *pHeader2 = (const BITMAPV4HEADER *)(pbmHeader);
			if ((pHeader2->bV4RedMask != 0x00FF0000) ||
				(pHeader2->bV4GreenMask != 0x0000FF00) ||
				(pHeader2->bV4BlueMask != 0x000000FF))
			{
				wprintf_s(L"Invalid RGB channel masks.\n");
				return -1;
			}
		}
		else
		{
			wprintf_s(L"Compression unsupported.\n");

			return -1;
		}
	}

	auto width = pbmHeader->biWidth;
	auto height = pbmHeader->biHeight;
	if (height < 0)
	{
		wprintf(L"'Upside down' (negative height) bitmaps not supported.\n");
		return -1;
	}

	auto pBits = (const byte *)pFileMapping.get() + pbmh->bfOffBits;

	std::unique_ptr<CBitmapHandler> pHandler = nullptr;

	switch (pbmHeader->biBitCount)
	{
	case 32:
		pHandler = std::make_unique<C32BitBitmapHandler>(pBits, (uint16_t)pbmHeader->biWidth, (uint16_t)pbmHeader->biHeight);
		break;

	case 24:
		pHandler = std::make_unique<C24BitBitmapHandler>(pBits, (uint16_t)pbmHeader->biWidth, (uint16_t)pbmHeader->biHeight);
		break;

	case 8:
		pHandler = std::make_unique<C8BitBitmapHandler>(pBits, (uint16_t)pbmHeader->biWidth, (uint16_t)pbmHeader->biHeight, 
			(const byte *)pFileMapping.get()+pbmHeader->biSize+sizeof(BITMAPFILEHEADER));
		break;
	}

	if (!pHandler)
	{
		wprintf_s(L"Invalid bit depth of %d.\n", pbmHeader->biBitCount);

		return -1;
	}

	auto numPaletteEntries = pHandler->GetNumPaletteEntries();

	if (numPaletteEntries > 256)
	{
		wprintf_s(L"Bitmap has too many unique colors.  Must be 256 or fewer colors.\n");

		return -1;
	}

	printHeader(name, argv[1]);

	unsigned int numBytes = 0;

	for (uint16_t i = 0; i < height; i++)
	{
		WORD currentColor = pHandler->GetPixelColor(0, i);

		int count = 1;

		for (uint16_t j = 1; j < width; j++)
		{
			uint16_t color = pHandler->GetPixelColor(j, i);

			if ((color != currentColor) || (count == 0x00ff))
			{
				size_t currentPaletteIndex = pHandler->GetPaletteIndex(currentColor);

				if (count > 15 || numPaletteEntries > 16)
				{
					wprintf_s(L"0x%02zx, 0x%02x, ", currentPaletteIndex, (unsigned int)count);
					numBytes += 2;
				}
				else
				{
					//  Pack info into one byte
					byte b = (byte) (currentPaletteIndex | count << 4);
					wprintf_s(L"0x%02x, ", b);
					numBytes += 1;
				}

				currentColor = color;
				count = 1;
			}
			else
			{
				count++;
			}
		}

		if (count != 0)
		{
			size_t currentPaletteIndex = pHandler->GetPaletteIndex(currentColor);

			if (count > 15 || numPaletteEntries > 16)
			{
				wprintf_s(L"0x%02zx, 0x%02x, ", currentPaletteIndex, count);
				numBytes += 2;
			}
			else
			{
				//  Pack info into one byte
				byte b = (byte)(currentPaletteIndex | count << 4);
				wprintf_s(L"0x%02x, ", b);
				numBytes += 1;
			}
		}

		wprintf_s(L"\n\t");

	}
	wprintf_s(L"\n}; // %dx%d Bitmap (%d pixels) in %d bytes\n\n", width, height, (width * height), numBytes);

	dumpPalette(name, pHandler.get());

	byte flags = 0;

	if (numPaletteEntries <= 16)
	{
		//  set 'small palette' flag
		flags |= 0x01;
	}


	wprintf_s(
		LR"(
//  Some platforms don't fully implement the pgmspace.h interface.  Assume ordinary
//  addresses will do.
#if not defined pgm_get_far_address
#define pgm_get_far_address(x) ((uint32_t)(&(x)))
#endif

//  Returns the info needed to render the bitmap.
inline void get_%s_RLEBM(
	RLEBitmapInfo &bmInfo)
{
	bmInfo.pRLEBM_data_far = pgm_get_far_address(%s_RLEBM_data);
	bmInfo.pRLEBM_palette_far = pgm_get_far_address(%s_RLEBM_palette);
	bmInfo.width = %d;
	bmInfo.height = %d;
	bmInfo.flags = 0x%02x;
}
)",
name, name, name, width, height, flags);

	return 0;
}

